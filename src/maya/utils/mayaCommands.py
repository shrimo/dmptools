import maya.cmds as cmds
import maya.mel as mel
import os
import time
import subprocess
import fnmatch
import math

from dmptools.settings import SettingsManager

# strings to be generated by the install
PLATFORM = '!PLATFORM!'

if '!PLATFORM!' == 'Linux':
    from dmptools_misc.linux import fdUtils

# globals
SETTINGS = SettingsManager('maya')
perspNear = 1
perspFar = 200000

SETTINGS.add('default_perspNear', perspNear)
SETTINGS.add('default_perspFar', perspFar)

def nextFrame():
    cmds.currentTime(cmds.currentTime(q=True)+1)

def previousFrame():
    cmds.currentTime(cmds.currentTime(q=True)-1)

def getNodesInHierarchy(shapes=False, select=False):
    longList = []
    cmds.select(hi=True)
    for node in cmds.ls(sl=True, l=True, r=True):
        if shapes:
            if cmds.listRelatives(node, shapes=True):
                longList.extend(cmds.listRelatives(node, shapes=True, path=True))
        else:
            longList.extend(cmds.ls(node, path=True))
    if select:
        cmds.select(longList, r=True)
    
    return longList

def getFdState():
    fdState = fdUtils.getOpenedFiles()
    SETTINGS.add('fdState', fdState)
    print '\nget the current list of opened files...',

def flushFd():
    if SETTINGS.get('fdState'):
        fdUtils.closeOpenedFiles(filterList=SETTINGS.get('fdState'))
        print '\nflushing the opened files since last get...',
    else:
        print '\nno current fd list found...',

def getLenFd(printR=True):
    if printR:
        print '\n'+str(len(fdUtils.getOpenedFiles()))+' opened files.',
    else:
        return len(fdUtils.getOpenedFiles())

def openCharcoalEditor():
    mel.eval('charcoalEditor;')

def openHypergraph():
    mel.eval('HypergraphDGWindow;')

def openOutliner():
    mel.eval('OutlinerWindow;')

def openNamespaceEditor():
    mel.eval('NamespaceEditor;')

def openScriptEditor():
    mel.eval("ScriptEditor;")

def openNodeEditor():
    mel.eval('NodeEditorWindow;')

def createNodeWindow():
    mel.eval('CreateNodeWindow;')

def openUvTextureEditor():
    mel.eval('TextureViewWindow;')

def openHypershade():
    mel.eval('HypershadeWindow;')

def checkOverlappingObjects(selection):
    xforms = []
    wrongXforms = []
    for node in selection:
        nodeM = cmds.xform(node, ws=True, m=True, q=True)
        if nodeM in xforms:
            wrongXforms.append(node)
        else:
            xforms.append(nodeM)
    if wrongXforms:
        return wrongXforms
    else:
        return None

def getActiveCamera():
    pane = cmds.getPanel(wf=True)
    activeCamera = cmds.modelPanel(pane, camera=True, q=True)

    return activeCamera

def fixClipPlanes():
    activeCamera = getActiveCamera()
    activeCameraShape = cmds.listRelatives(activeCamera, shapes=True)[0]
    cmds.setAttr(activeCameraShape+'.nearClipPlane', 10)
    cmds.setAttr(activeCameraShape+'.farClipPlane', 1000000)

def getNamespace():
    selection = cmds.ls(sl=True)
    root = ':'
    if selection:
        node = selection[0]
        if '|' in node:
            node = node.split('|')[-1]
    
        nsSplit = node.split(':')[:-1]    
        ns = root+root.join(nsSplit)+root
        return ns
    else:
        return ':'

def udimFromNode(node):
    uPos, vPos = cmds.polyEditUV(node+'.map[1]', q=True)
    uTile = int(math.floor(uPos))
    vTile = int(math.floor(vPos))
    udim = 1000+(uTile+1)+(vTile*10)
    
    return udim, uTile, vTile

def uvFromUdim(udim):
    v = (udim-1000-1)/10
    u = (udim-1000-1-(v*10))
    
    return u, v

def setNamespace():
    ns = getNamespace()
    print 'set namespace to: "'+ns+'"',

    return cmds.namespace(set=ns)

def getNodeType(node=cmds.ls(sl=True, long=True)):
    if node:
        nodeShape = cmds.listRelatives(node[0], shapes=True, f=True)[0]
        return cmds.nodeType(nodeShape)
    else:
        cmds.warning('Please select a node')
        return None

def openFile(filename, software='gedit', shell=True):
    """ open a given file with a given software """
    if not os.path.exists(filename):
        raise UserWarning("This file doesn't exists...")
    if not software:
        raise UserWarning("Software not specified...")
    command = software+' '+filename+' &'
    popObj = subprocess.Popen(command, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    out = popObj.communicate()
    
    return out[0]

def replaceDefaultPersp():
    """ delete the default persp and recreate a new fresh one """
    # find the default startup persp and delete it
    defaultPersp = mel.eval('findStartUpCamera( "persp");')
    cmds.camera(defaultPersp, e=True, sc=False)
    cmds.delete(defaultPersp)
    # create new persp, hide it and set it as default startup persp
    newPersp = cmds.camera(n='persp', hc="viewSet -p %camera")
    cmds.setAttr(newPersp[0]+'.visibility', False)
    cmds.rename(newPersp[0], 'persp')
    cmds.camera('persp', e=True, sc=True)

def texmaker(inputfile, outputfile):
    """
        convert exr input file to tex file
    """
    cmd = 'txmake -resize up -smode black -tmode black '+inputfile+' '+outputfile
    print '> converting', inputfile, outputfile
    popObj = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    out = popObj.communicate()
    return out[0]

       
def setPerspSetting():
    if cmds.ls('perspShape'):
        cmds.setAttr('perspShape.nearClipPlane', perspNear)
        cmds.setAttr('perspShape.farClipPlane', perspFar)
    else:
        cmds.warning('Cannot find the persp camera!')

def selectObjectsFromShader(shader):
    """
    select objects with lambert1 assigned
    """
    cmds.hyperShade(objects=shader)

def setUserSetting():
    
    # ask for a Setting name
    result = cmds.promptDialog(
                    title='Save selection',
                    message='Enter Name:',
                    button=['OK', 'Cancel'],
                    defaultButton='OK',
                    cancelButton='Cancel',
                    dismissString='Cancel')
    
    if result == 'OK':
        inputText = cmds.promptDialog(query=True, text=True)
        SETTINGS.add(inputText, cmds.ls(sl=True))
        print SETTINGS.get('faceSelection')

def getUserSetting():
    allSettings = SETTINGS.getAll()
    lines = []
    for item in allSettings:
        lines.append(item.keys()[0])
    
    if cmds.window('settingsWindow', exists=True):
        cmds.deleteUI('settingsWindow', window=True)

    window = cmds.window('settingsWindow')
    cmds.paneLayout()
    cmds.textScrollList('settingsList',
                        numberOfRows=8,
                        allowMultiSelection=True,
                        append=lines,
                        dcc=selectSetting)
    
    cmds.showWindow('settingsWindow')

def selectSetting():
    settingText = cmds.textScrollList('settingsList',
                        q=True,
                        si=True)
    try:
        cmds.select(SETTINGS.get(settingText[0]))
    except:
        print 'failed to select setting...'
        
def invertSelection():
    """invert selection"""
    mel.eval('invertSelection;')

def replaceXformSel():
    """duplicate the first object in selection and move it to the world space
        coordinates of the next object in selection.
    """
    source = cmds.ls(sl=True)[0]
    rest = cmds.ls(sl=True)[1:]
    for node in rest:
        dup = cmds.duplicate(source)[0]
        translate = cmds.xform(node, ws=True, t=True, q=True)
        rotation = cmds.xform(node, ws=True, ro=True, q=True)
        cmds.xform(dup, t=translate, ro=rotation)

def selectInsideFaces():
    """select all the edges inside an object except the border."""
    sel = cmds.ls(sl=True)[0]
    cmds.select(sel+'.e[*]')
    mel.eval('polyConvertToShellBorder;')
    mel.eval('ConvertSelectionToFaces;')
    mel.eval('invertSelection')

def toggleVertexColorDisplay():
    """toggle the color vertex display"""
    sel = cmds.ls(sl=True)
    if sel:
        for node in sel:
            mel.eval('toggleShadeMode;')
    else:
        cmds.select(all=True)
        mel.eval('toggleShadeMode;')

def headsUpDisplayMessage(message):
    """function that displays a custom heads up display message"""
    cmds.headsUpMessage(message,
                    verticalOffset=350,
                    horizontalOffset=0)

def shortestEdgePath():
    """enter polyShortestPathCtx """
    polyPathContex = cmds.polyShortestPathCtx()
    cmds.setToolTo(polyPathContex)

def shortestEdgePathRelease():
    cmds.setToolTo('moveSuperContext')
    cmds.selectMode(component=True)
    cmds.selectType(eg=True)

def switchObjectTumble():
    headsUpDisplayMessage(message='Tumble object focus: '+str(not cmds.tumbleCtx('tumbleContext', objectTumble=True, q=True)))
    cmds.tumbleCtx('tumbleContext', ac=True,
        objectTumble=not cmds.tumbleCtx('tumbleContext', objectTumble=True, q=True),
        e=True)

def unfoldAndRotate(sel):
    # unfold horizontal
    cmds.unfold(sel+'.map[*]',
        i=5000,
        ss=0.001,
        gb=0.0,
        gmb=0.5,
        pub=False,
        ps= False,
        oa=2, # 1: vertical, 2:horizontal
        us=False)
    # unfold vertical
    cmds.unfold(sel+'.map[*]',
        i=5000,
        ss=0.001,
        gb=0.0,
        gmb=0.5,
        pub=False,
        ps= False,
        oa=1, # 1: vertical, 2:horizontal
        us=False)
    # rotate UVs
    cmds.polyEditUV(pivotU=0.5, pivotV=0.5, angle=90)
    
def unwrapTerrain(sel):
    # unwrap planar Y
    cmds.polyProjection(sel+'.f[*]',
                                    ch=False,
                                    type='Planar',
                                    ibd=True,
                                    isu=1,
                                    isv=1,
                                    md='y')
    # apply unfoldAndRotate x times
    for i in range(4):
        unfoldAndRotate(sel)

def proMode():
    """
    pro mode
    """
    mel.eval('ToggleUIElements')

def freezeHistory():
    """
    freeze transfoms and delete history
    """
    cmds.makeIdentity(apply=True, t=1, r=1, s=1, n=0)
    cmds.delete(ch=True)

def freezeCenterPivot():
    """
    freeze transfoms, delete history and center pivot
    """
    cmds.makeIdentity(apply=True, t=1, r=1, s=1, n=0)
    cmds.delete(ch=True)
    cmds.xform(cp=True)

def centerPivot():
    """
    center pivot
    """
    cmds.xform(cp=True)

def getVertexColor():
    """
    return a dict of vertex and their color
    """
    selection = cmds.ls(sl=True)
    colors = {}
    for obj in selection:
        colors[obj] = {}
        for v in range(cmds.polyEvaluate(v=True)):
            cmds.select(obj+'.vtx['+str(v)+']', r=True)
            colors[obj][v] = cmds.polyColorPerVertex(query=True, g=True, b=True)
    return colors

def newScriptEditor():
    """
    simpler script editor test
    """
    win = cmds.window(t='New Script Editor', menuBar= True, w = 650, h = 300)
    form = cmds.formLayout()
    pane = cmds.paneLayout(configuration='horizontal2', paneSize=[[1,100,40],[2,100,60]])
    # top layout
    formTop = cmds.formLayout()
    reporter = cmds.cmdScrollFieldReporter('reporter')
    cmds.setParent('..')
    cmds.formLayout(formTop, e=True,
            attachForm=\
                [
                    (reporter, "top", 5),
                    (reporter, "bottom", 5),
                    (reporter, "left", 5),
                    (reporter, "right", 5),
                ]
        )
    cmds.paneLayout(pane, edit=True, setPane = [formTop, 2])
    # bottom layout
    formBottom = cmds.formLayout()
    shelf = cmds.shelfTabLayout()
    tab1 = cmds.cmdScrollFieldExecuter('python1', sourceType="python")
    cmds.setParent('..')
    cmds.formLayout(formBottom, e=True,
            attachForm=\
                [
                    (shelf, "top", 5),
                    (shelf, "bottom", 5),
                    (shelf, "left", 5),
                    (shelf, "right", 5),
                ]
        )
    
    cmds.paneLayout(pane, edit=True, setPane = [formTop, 1])
    
    cmds.formLayout(form, e=True,
            attachForm=\
                [
                    (pane, "top", 5),
                    (pane, "bottom", 5),
                    (pane, "left", 5),
                    (pane, "right", 5),
                ]
        )
    
    cmds.showWindow()

def launchTerminal():
    cmd = 'gnome-terminal'
    popObj = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    out = popObj.communicate()

def launchConsole():
    """launch console2 from maya"""
    
    # get the console path from default
    defaultConsolePath = [
        'C:/Program Files/Console2/Console.exe',
        'C:/Program Files (x86)/Console2/Console.exe',
        ]
    for path in defaultConsolePath:
        if os.path.exists(path):
            SETTINGS.add('terminator', path)

    consolePath = SETTINGS.get('terminator')
    if consolePath and os.path.exists(consolePath):
        # launch console
        subprocess.Popen(consolePath[0])
    else:
        # ask for the console exe path
        filedialog = cmds.fileDialog2(cap='Please give me the path of Console.exe !',
                        fm=1,
                        dir='C:\\Program Files\\',
                        ff='*.exe')
        if filedialog:
            consolePath = str(filedialog[0])
            if os.path.exists(consolePath):
                # setting Setting
                SETTINGS.add('terminator', consolePath)
                # launch console
                subprocess.Popen(consolePath)
        else:
            raise UserWarning('No exe found !')

def sublimeTextPathFinder():
    """launch sublime text from maya"""
    
    # get the sublime text path from default
    defaultSublimePath = [
        'C:/Program Files/sublime_text/sublime_text.exe',
        'C:/Program Files/Sublime Text 2/sublime_text.exe',
        'C:/Program Files (x86)/Sublime Text 2/sublime_text.exe',
        ]
    for path in defaultSublimePath:
        if os.path.exists(path):
            SETTINGS.add('sublime_text_path', path)

    sublimeTextPath = SETTINGS.get('sublime_text_path')
    if sublimeTextPath and os.path.exists(sublimeTextPath):
        # launch sublime text
        subprocess.Popen(sublimeTextPath[0])
    else:
        # ask for the sublime text exe path
        filedialog = cmds.fileDialog2(cap='Please give me the path of Sublime Text.exe !',
                        fm=1,
                        dir='C:\\Program Files\\',
                        ff='*.exe')
        if filedialog:
            sublimeTextPath = str(filedialog[0])
            if os.path.exists(sublimeTextPath):
                # setting Setting
                SETTINGS.add('sublime_text_path', sublimeTextPath)
                return sublimeTextPath
        else:
            raise UserWarning('No exe found !')

def launchSublimeText():
    path = sublimeTextPathFinder()
    subprocess.Popen(path)

def nukePathFinder():
    """
    get nuke exe/bin path
    """
    # windows
    if PLATFORM == 'Windows':
        defaultNukePath = [
        'C:/Program Files/Nuke7.0v4/Nuke7.0.exe',
                            ]
        searchDir = 'C:\\Program Files\\'
        fileFilter = '*.exe'
    # linux
    if PLATFORM == 'Linux':
        defaultNukePath = [
        os.getenv('NUKE')+'/nuke',
                            ]
        searchDir = '/'
        fileFilter = '*'

    # check if the default path exists 
    for path in defaultNukePath:
        if os.path.exists(path):
            SETTINGS.add('nukePath', path)
    
    # get the nuke path setting if exists
    nukePath = SETTINGS.get('nukePath')
    if nukePath:
        if os.path.exists(nukePath):
            return nukePath
        else:
            raise UserWarning('No exe found !')
    else:
        # ask for the sublime text exe path
        filedialog = cmds.fileDialog2(cap='Please give me the path of Nuke exe/bin !',
                        fm=1,
                        dir=searchDir,
                        ff=fileFilter)
        if filedialog:
            nukePath = str(filedialog[0])
            if os.path.exists(nukePath):
                # setting setting
                SETTINGS.add('nukePath', nukePath)
                return nukePath
            else:
                raise UserWarning('No Nuke found !')
        else:
            raise UserWarning('No Nuke found !')

def launchNuke():
    path = nukePathFinder()
    subprocess.Popen(path+" --nukex")

def setDefaultRenderer():
    panel = cmds.getPanel(wf=True)
    cmds.modelEditor(panel, shadows=False, displayLights='default', e=True)
    cmds.modelEditor(panel, rnm='base_OpenGL_Renderer', e=True)
    headsUpDisplayMessage('Default renderer')

def setHardwareRenderer():
    panel = cmds.getPanel(wf=True)
    cmds.modelEditor(panel, shadows=True, displayLights='default', e=True)
    cmds.modelEditor(panel, rnm='hwRender_OpenGL_Renderer', e=True)
    headsUpDisplayMessage('Hardware renderer')

def setViewport2Renderer():
    panel = cmds.getPanel(wf=True)
    cmds.modelEditor(panel, shadows=True, displayLights='default', e=True)
    cmds.modelEditor(panel, rnm='ogsRenderer', e=True)
    headsUpDisplayMessage('Viewport 2 renderer')

def assignSurfaceShader(name="", values=(0,0,0)):

    selection = cmds.ls(sl = True)
    print name, selection, values[0], values[1], values[2]
    
    if selection:
        # if the shader already exists
        if name in cmds.ls("*", type = "surfaceShader") and name+"SG" in cmds.ls("*", type = "shadingEngine"):
            for node in selection:
                try:
                    cmds.select(node, r = True)
                    cmds.sets(node, e = True, forceElement = name+"SG")
                except:
                    pass
                    
        # otherwise create the shader
        else:
            shader = cmds.shadingNode('surfaceShader', asShader = True, name = name)
            shadingGroup = cmds.sets(shader, renderable = True, noSurfaceShader = True, empty = True, name = name+"SG")
            cmds.connectAttr(shader+".outColor", shadingGroup+".surfaceShader", force = True)
            cmds.setAttr(shader+".outColor", values[0], values[1], values[2], type = "double3")
        
            for node in selection:
                try:
                    cmds.sets(node, e = True, forceElement = name+"SG")
                except:
                    pass
            
        cmds.select(selection, r = True)

def askFlushUndo():
    confirm = cmds.confirmDialog(t="flushUndo",
                                 m='Do you want to flush undo ?',
                                 ma="center",
                                 b=['Yes','No'],
                                 db='Yes',
                                 cb='No',
                                 ds='No')

    if confirm == "Yes":
        print "flushUndo..."
        cmds.flushUndo()
    else:
        print "abort..."

def undoQueue(undos=100):
    # set the undo queue 
    cmds.undoInfo(state=True, infinity=False, length=undos)
    
def switchHighlightedSelection():
    panel = cmds.getPanel(wf=True)
    cmds.modelEditor(panel, edit=True, sel=not cmds.modelEditor(panel, query=True, sel=True))
    headsUpDisplayMessage('Selection highlight: '+str(cmds.modelEditor(panel, query=True, sel=True)))

def toggleNormals():
    #toggle normals
    cmds.polyOptions(r=True,
                    f=True,
                    dn=not cmds.polyOptions(q=True, dn=True))
    headsUpDisplayMessage('Polygon normal display: '+str(cmds.polyOptions(q=True, dn=True)))
    
def unselectAll():
    # unselect all
    cmds.selectMode(component=True)
    cmds.selectMode(object=True)
    cmds.select(clear=True)
    
def setWireframe():
    panel = cmds.getPanel(wf=True)
    cmds.modelEditor(panel,
                    e=True,
                    wireframeOnShaded=not cmds.modelEditor(panel, query=True, wireframeOnShaded=True))
    headsUpDisplayMessage('Wireframe on shaded: '+str(cmds.modelEditor(panel, query=True, wireframeOnShaded=True)))

def setBackfaceCulling():
    panel = cmds.getPanel(wf=True)
    cmds.modelEditor(panel,
                    e=True,
                    backfaceCulling=not cmds.modelEditor(panel, query=True, backfaceCulling=True))
    headsUpDisplayMessage('Backface culling: '+str(cmds.modelEditor(panel, query=True, backfaceCulling=True)))
    
def setDefaultMaterial():
    panel = cmds.getPanel(wf=True)
    cmds.modelEditor(panel, edit=True, useDefaultMaterial=not cmds.modelEditor(panel, query=True, useDefaultMaterial=True))
    headsUpDisplayMessage('Default material: '+str(cmds.modelEditor(panel, query=True, useDefaultMaterial=True)))


def importScene():
    """import scene exported from nuke"""
    crosswalkFile = 'nukeToMaya.info'
    if os.path.exists(crosswalkFile):
        fileInfo = open(crosswalkFile, 'r')
        mayaFile = fileInfo.readlines()[-1].split('=')[-1][:-1]
        if os.path.exists(mayaFile):
            cmds.file(mayaFile, i = True, type = 'mayaAscii', ra = True)
        else:
            print mayaFile
            mel.eval('warning "File '+mayaFile+' not found !"')

def isolateSelection():
    """isolate selection toggle"""
    activePanel = cmds.getPanel(wf=True)
    mel.eval('isoSelectAutoAddNewObjs '+activePanel+' true;')
    mel.eval("enableIsolateSelect {0} {1};".format(activePanel, str(not cmds.isolateSelect(activePanel, q=True, state=True)).lower()))

def hideSel():
    
    sel = cmds.ls(sl=True)
    for node in sel:
        cmds.setAttr(node+'.visibility', 0)
        
def hideSelSwitch():
    
    sel = cmds.ls(sl=True)
    for node in sel:
        cmds.setAttr(node+'.visibility', not cmds.getAttr(node+'.visibility'))

def hideSelRelease():
    
    sel = cmds.ls(sl=True, dag=True)
    for node in sel:
        cmds.setAttr(node+'.visibility', 1)

def assignBlackShader():

    global switch
    activeModel = cmds.getPanel(wf=True)
    cmds.modelEditor(activeModel, e=True, udm=1)
    cmds.displayRGBColor( 'background', 0, 0, 0 )
    cmds.setAttr('lambert1.color', 0, 0, 0, type="double3")
    cmds.setAttr('lambert1.diffuse', 0)
    cmds.displayRGBColor('userDefined1', 1 ,1 ,1 )

    for node in cmds.ls(sl = True):
        cmds.color(ud = 1) # assign white wireframes
    switch = 1

def assignDefaultShader():

    global switch
    activeModel = cmds.getPanel(wf=True)
    cmds.modelEditor(activeModel, e=True, udm=0)
    cmds.displayRGBColor( 'background', 0.61, 0.61, 0.61 )
    cmds.setAttr('lambert1.color', 0.5, 0.5, 0.5, type="double3")
    cmds.setAttr('lambert1.diffuse', 0.5)
    for node in cmds.ls(sl=True):
        cmds.color() # assign default wireframes
    switch = 1

def switchShaders():

    global switchshader
    try:
        switchshader
    except:
        switchshader = 1

    if switchshader == 1:
        assignBlackShader()
        switchshader = 0
    elif switchshader == 0:
        assignDefaultShader()
        switchshader = 1

def getCam():
    sel = cmds.ls(sl = True)
    if sel:
        camShape = cmds.listRelatives(sel[0])[0]
        if cmds.nodeType(camShape) == 'camera':
            setRenderCamera(sel[0], camShape)

def cameraPanTool():
    headsUpDisplayMessage('Camera 2d pan mode')
    panContext = cmds.panZoomCtx(panMode=True)
    cmds.setToolTo(panContext)
    
def cameraZoomTool():
    headsUpDisplayMessage('Camera 2d zoom mode')
    zoomContext = cmds.panZoomCtx(zoomMode=True)
    cmds.setToolTo(zoomContext)

def resetPanZoom():
    panel = cmds.getPanel(wf=True)
    cameraNode = cmds.modelPanel(panel, q=True, camera=True)

    cmds.setAttr(cameraNode+".zoom", 1)
    cmds.setAttr(cameraNode+".horizontalPan", 0)
    cmds.setAttr(cameraNode+".verticalPan", 0)

def selectNgones():
    panel = cmds.getPanel(withFocus=True)
    cmds.modelEditor(panel, e=True, manipulators=False)
    cmds.selectMode(component=True)
    cmds.selectType(fc=1)
    cmds.polySelectConstraint(m=3, t=8, sz=3)
    
def selectNgonesRelease():
    panel = cmds.getPanel(withFocus=True)
    cmds.modelEditor(panel, e=True, manipulators=True)
    cmds.select(clear=True)
    cmds.selectMode(object=True)
    cmds.polySelectConstraint(m=0)

def switchSelectNgones():
    global switchselectngones
    try:
        switchselectngones
    except:
        switchselectngones = 1

    if switchselectngones == 1:
        selectNgones()
        switchselectngones = 0
    elif switchselectngones == 0:
        selectNgonesRelease()
        switchselectngones = 1

def selectTriangles():
    panel = cmds.getPanel(withFocus=True)
    cmds.modelEditor(panel, e=True, manipulators=False)
    cmds.selectMode(component=True)
    cmds.selectType(fc=1)
    cmds.polySelectConstraint(m=3, t=8, sz=1)

def selectTrianglesRelease():
    panel = cmds.getPanel(withFocus=True)
    cmds.modelEditor(panel, e=True, manipulators=True)
    cmds.select(clear=True)
    cmds.selectMode(object=True)
    cmds.polySelectConstraint(m=0)

def switchSelectTriangles():
    global switchselecttriangles
    try:
        switchselecttriangles
    except:
        switchselecttriangles = 1

    if switchselecttriangles == 1:
        selectTriangles()
        switchselecttriangles=0
    elif switchselecttriangles == 0:
        selectTrianglesRelease()
        switchselecttriangles = 1

def setDefaultLight():
    activePanel = cmds.getPanel(wf=True)
    cmds.modelEditor(activePanel, e=True, dl="default")

def setAllLight():
    activePanel = cmds.getPanel(wf=True)
    cmds.modelEditor(activePanel, edit=True, displayLights='all')

def switchLight():
    global switchlight
    try:
        switchlight
    except:
        switchlight = 1

    if switchlight == 1:
        setDefaultLight()
        switchlight = 0
    elif switchlight == 0:
        setAllLight()
        switchlight = 1
   
def lockPickNodes(lock=True):
    for node in cmds.ls(sl=True):
        try:
            cmds.lockNode(node, lock=lock)
        except:
            cmds.warning("cannot lockPick this node: "+str(node))
            
